/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "engine_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace engine {


HelloRequest::~HelloRequest() noexcept {
}


void HelloRequest::__set_name(const std::string& val) {
  this->name = val;
}
std::ostream& operator<<(std::ostream& out, const HelloRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HelloRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HelloRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HelloRequest");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HelloRequest &a, HelloRequest &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

HelloRequest::HelloRequest(const HelloRequest& other0) {
  name = other0.name;
  __isset = other0.__isset;
}
HelloRequest& HelloRequest::operator=(const HelloRequest& other1) {
  name = other1.name;
  __isset = other1.__isset;
  return *this;
}
void HelloRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HelloRequest(";
  out << "name=" << to_string(name);
  out << ")";
}


HelloReply::~HelloReply() noexcept {
}


void HelloReply::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const HelloReply& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HelloReply::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HelloReply::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HelloReply");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HelloReply &a, HelloReply &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

HelloReply::HelloReply(const HelloReply& other2) {
  message = other2.message;
  __isset = other2.__isset;
}
HelloReply& HelloReply::operator=(const HelloReply& other3) {
  message = other3.message;
  __isset = other3.__isset;
  return *this;
}
void HelloReply::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HelloReply(";
  out << "message=" << to_string(message);
  out << ")";
}


PiRequest::~PiRequest() noexcept {
}


void PiRequest::__set_samples(const int64_t val) {
  this->samples = val;
}
std::ostream& operator<<(std::ostream& out, const PiRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PiRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->samples);
          this->__isset.samples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PiRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PiRequest");

  xfer += oprot->writeFieldBegin("samples", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->samples);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PiRequest &a, PiRequest &b) {
  using ::std::swap;
  swap(a.samples, b.samples);
  swap(a.__isset, b.__isset);
}

PiRequest::PiRequest(const PiRequest& other4) noexcept {
  samples = other4.samples;
  __isset = other4.__isset;
}
PiRequest& PiRequest::operator=(const PiRequest& other5) noexcept {
  samples = other5.samples;
  __isset = other5.__isset;
  return *this;
}
void PiRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PiRequest(";
  out << "samples=" << to_string(samples);
  out << ")";
}


PiReply::~PiReply() noexcept {
}


void PiReply::__set_pi(const double val) {
  this->pi = val;
}

void PiReply::__set_inside(const int64_t val) {
  this->inside = val;
}

void PiReply::__set_total(const int64_t val) {
  this->total = val;
}

void PiReply::__set_seed(const int64_t val) {
  this->seed = val;
}
std::ostream& operator<<(std::ostream& out, const PiReply& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PiReply::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->pi);
          this->__isset.pi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->inside);
          this->__isset.inside = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total);
          this->__isset.total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->seed);
          this->__isset.seed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PiReply::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PiReply");

  xfer += oprot->writeFieldBegin("pi", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->pi);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inside", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->inside);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("seed", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->seed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PiReply &a, PiReply &b) {
  using ::std::swap;
  swap(a.pi, b.pi);
  swap(a.inside, b.inside);
  swap(a.total, b.total);
  swap(a.seed, b.seed);
  swap(a.__isset, b.__isset);
}

PiReply::PiReply(const PiReply& other6) noexcept {
  pi = other6.pi;
  inside = other6.inside;
  total = other6.total;
  seed = other6.seed;
  __isset = other6.__isset;
}
PiReply& PiReply::operator=(const PiReply& other7) noexcept {
  pi = other7.pi;
  inside = other7.inside;
  total = other7.total;
  seed = other7.seed;
  __isset = other7.__isset;
  return *this;
}
void PiReply::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PiReply(";
  out << "pi=" << to_string(pi);
  out << ", " << "inside=" << to_string(inside);
  out << ", " << "total=" << to_string(total);
  out << ", " << "seed=" << to_string(seed);
  out << ")";
}


Matrix::~Matrix() noexcept {
}


void Matrix::__set_rows(const int32_t val) {
  this->rows = val;
}

void Matrix::__set_cols(const int32_t val) {
  this->cols = val;
}

void Matrix::__set_data(const std::vector<double> & val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const Matrix& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Matrix::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rows);
          this->__isset.rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cols);
          this->__isset.cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->data.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += iprot->readDouble(this->data[_i12]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Matrix::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Matrix");

  xfer += oprot->writeFieldBegin("rows", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cols", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->cols);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->data.size()));
    std::vector<double> ::const_iterator _iter13;
    for (_iter13 = this->data.begin(); _iter13 != this->data.end(); ++_iter13)
    {
      xfer += oprot->writeDouble((*_iter13));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Matrix &a, Matrix &b) {
  using ::std::swap;
  swap(a.rows, b.rows);
  swap(a.cols, b.cols);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

Matrix::Matrix(const Matrix& other14) {
  rows = other14.rows;
  cols = other14.cols;
  data = other14.data;
  __isset = other14.__isset;
}
Matrix& Matrix::operator=(const Matrix& other15) {
  rows = other15.rows;
  cols = other15.cols;
  data = other15.data;
  __isset = other15.__isset;
  return *this;
}
void Matrix::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Matrix(";
  out << "rows=" << to_string(rows);
  out << ", " << "cols=" << to_string(cols);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


MatMulRequest::~MatMulRequest() noexcept {
}


void MatMulRequest::__set_a(const Matrix& val) {
  this->a = val;
}

void MatMulRequest::__set_b(const Matrix& val) {
  this->b = val;
}
std::ostream& operator<<(std::ostream& out, const MatMulRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MatMulRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->a.read(iprot);
          this->__isset.a = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->b.read(iprot);
          this->__isset.b = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatMulRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatMulRequest");

  xfer += oprot->writeFieldBegin("a", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->a.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("b", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->b.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatMulRequest &a, MatMulRequest &b) {
  using ::std::swap;
  swap(a.a, b.a);
  swap(a.b, b.b);
  swap(a.__isset, b.__isset);
}

MatMulRequest::MatMulRequest(const MatMulRequest& other16) {
  a = other16.a;
  b = other16.b;
  __isset = other16.__isset;
}
MatMulRequest& MatMulRequest::operator=(const MatMulRequest& other17) {
  a = other17.a;
  b = other17.b;
  __isset = other17.__isset;
  return *this;
}
void MatMulRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatMulRequest(";
  out << "a=" << to_string(a);
  out << ", " << "b=" << to_string(b);
  out << ")";
}


MatReply::~MatReply() noexcept {
}


void MatReply::__set_c(const Matrix& val) {
  this->c = val;
}
std::ostream& operator<<(std::ostream& out, const MatReply& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MatReply::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->c.read(iprot);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatReply::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatReply");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->c.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatReply &a, MatReply &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.__isset, b.__isset);
}

MatReply::MatReply(const MatReply& other18) {
  c = other18.c;
  __isset = other18.__isset;
}
MatReply& MatReply::operator=(const MatReply& other19) {
  c = other19.c;
  __isset = other19.__isset;
  return *this;
}
void MatReply::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatReply(";
  out << "c=" << to_string(c);
  out << ")";
}


VectorStatsRequest::~VectorStatsRequest() noexcept {
}


void VectorStatsRequest::__set_data(const std::vector<double> & val) {
  this->data = val;
}

void VectorStatsRequest::__set_sample(const bool val) {
  this->sample = val;
}
std::ostream& operator<<(std::ostream& out, const VectorStatsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VectorStatsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->data.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += iprot->readDouble(this->data[_i24]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sample);
          this->__isset.sample = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VectorStatsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VectorStatsRequest");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->data.size()));
    std::vector<double> ::const_iterator _iter25;
    for (_iter25 = this->data.begin(); _iter25 != this->data.end(); ++_iter25)
    {
      xfer += oprot->writeDouble((*_iter25));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sample", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->sample);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VectorStatsRequest &a, VectorStatsRequest &b) {
  using ::std::swap;
  swap(a.data, b.data);
  swap(a.sample, b.sample);
  swap(a.__isset, b.__isset);
}

VectorStatsRequest::VectorStatsRequest(const VectorStatsRequest& other26) {
  data = other26.data;
  sample = other26.sample;
  __isset = other26.__isset;
}
VectorStatsRequest& VectorStatsRequest::operator=(const VectorStatsRequest& other27) {
  data = other27.data;
  sample = other27.sample;
  __isset = other27.__isset;
  return *this;
}
void VectorStatsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VectorStatsRequest(";
  out << "data=" << to_string(data);
  out << ", " << "sample=" << to_string(sample);
  out << ")";
}


VectorStatsReply::~VectorStatsReply() noexcept {
}


void VectorStatsReply::__set_count(const int64_t val) {
  this->count = val;
}

void VectorStatsReply::__set_sum(const double val) {
  this->sum = val;
}

void VectorStatsReply::__set_mean(const double val) {
  this->mean = val;
}

void VectorStatsReply::__set_variance(const double val) {
  this->variance = val;
}

void VectorStatsReply::__set_stddev(const double val) {
  this->stddev = val;
}

void VectorStatsReply::__set_min(const double val) {
  this->min = val;
}

void VectorStatsReply::__set_max(const double val) {
  this->max = val;
}
std::ostream& operator<<(std::ostream& out, const VectorStatsReply& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VectorStatsReply::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->sum);
          this->__isset.sum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->mean);
          this->__isset.mean = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->variance);
          this->__isset.variance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->stddev);
          this->__isset.stddev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VectorStatsReply::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VectorStatsReply");

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sum", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->sum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mean", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->mean);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("variance", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->variance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stddev", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->stddev);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VectorStatsReply &a, VectorStatsReply &b) {
  using ::std::swap;
  swap(a.count, b.count);
  swap(a.sum, b.sum);
  swap(a.mean, b.mean);
  swap(a.variance, b.variance);
  swap(a.stddev, b.stddev);
  swap(a.min, b.min);
  swap(a.max, b.max);
  swap(a.__isset, b.__isset);
}

VectorStatsReply::VectorStatsReply(const VectorStatsReply& other28) noexcept {
  count = other28.count;
  sum = other28.sum;
  mean = other28.mean;
  variance = other28.variance;
  stddev = other28.stddev;
  min = other28.min;
  max = other28.max;
  __isset = other28.__isset;
}
VectorStatsReply& VectorStatsReply::operator=(const VectorStatsReply& other29) noexcept {
  count = other29.count;
  sum = other29.sum;
  mean = other29.mean;
  variance = other29.variance;
  stddev = other29.stddev;
  min = other29.min;
  max = other29.max;
  __isset = other29.__isset;
  return *this;
}
void VectorStatsReply::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VectorStatsReply(";
  out << "count=" << to_string(count);
  out << ", " << "sum=" << to_string(sum);
  out << ", " << "mean=" << to_string(mean);
  out << ", " << "variance=" << to_string(variance);
  out << ", " << "stddev=" << to_string(stddev);
  out << ", " << "min=" << to_string(min);
  out << ", " << "max=" << to_string(max);
  out << ")";
}

} // namespace
